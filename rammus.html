<!DOCTYPE html>
<html lang="en">

<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

   <title>Rammus</title>
   <style>
      canvas {
      display: block;
      margin: 10px auto;
      width: 800px;
      height: 500px;
      }
   </style>

   <script src="./js/three.js"></script>
   <script src="./js/OrbitControls.js"></script>
   <script src="./js/SceneUtils.js"></script>
   <script src="js/dat.gui.js"></script>
   
</head>

<body>
   <h1><center>Rammus Roll</center></h1>
   <script id="rammuscode">
   
/*************************************************

      global variables
      
*************************************************/

      // parameters used in the scene
      var cameraParams = {
         near: 1,
         far: 1000,
         fov: 55, // degrees
         aspectRatio: 800 / 500, // from dimensions of the canvas, see CSS
         atX: 0,
         atY: 0,
         atZ: 0,
         eyeX: 0,
         eyeY: 40,
         eyeZ: 150,
         upX: 0,
         upY: 1,
         upZ: 0
      };
      
      var bgParams = {
         groundColor1: new THREE.Color(0xC2B48C),
         groundColor2: new THREE.Color(0x427646),
         groundSize: 600
      }
      
      var turretParams = {
         positionX: 0,
         positionY: 0,
         positionZ: 0,
         scaleY: 1,
         rotation: 0,
         headSize: 15,
         bodyHeight: 100,
         bodyWidth: 10,
         baseHeightRatio: 0.1,
         baseWidthRatio: 1.2
      }
      
      var params = {
         orbRadius: 1
      };
      
      var state = {};
      
      // colors and materials for the clown
      var clownMaterials = [
         new THREE.MeshBasicMaterial({ color: 0x8822BB }),  // 0 - purple
         new THREE.MeshBasicMaterial({ color: 0x22CC22 }),  // 1 - green
         new THREE.MeshBasicMaterial({ color: 0xE59B7D }),  // 2 - skin
         new THREE.MeshBasicMaterial({ color: 0x000000 }),  // 3 - black
         new THREE.MeshBasicMaterial({ color: 0xEEEEEE }),  // 4 - off white
         new THREE.MeshBasicMaterial({ color: 0xFFFF00 })   // 5 - yellow
      ];
      
/*************************************************

      functions
      
*************************************************/

      function deg2rad(degrees) {
         return degrees * 0.0174533;
      }
      
      function createTurret(turretParams) {
         let turret = new THREE.Object3D();
         
         // create the nested parts 
         let body = createBody(turretParams);
         let shield = createShield(turretParams);
         let wand = createWand(turretParams);
         
         // add the parts to the whole
         turret.add(body);
         turret.add(shield);
         turret.add(wand);
         
         // adjust whole
         // TODO: POSITION, ROTATION, SIZE SCALING, ETC
         
         return turret;
      }
      
      function createBody(turretParams) {
         // use alias
         let p = turretParams;
         
         let body = new THREE.Object3D();
         
         // create parts
         let head = new THREE.SphereGeometry(p.headSize, 32, 32);
         let mast = new THREE.CylinderGeometry(p.bodyWidth, p.bodyWidth, p.bodyHeight);
         let base = new THREE.CylinderGeometry(p.bodyWidth, p.bodyWidth, p.bodyHeight/10);
         
         return body;
      }
      
      function createShield(turretParams) {
         let shield = new THREE.Object3D();
         
         
         return shield;
      }
      
      function createWand(turretParams) {
         let wand = new THREE.Object3D();
         
         
         return wand;
      }
      
      // add background stuff such as the ground, skies (TODO), ambient light.
      function addBackground(bgParams, state) {
         let p = bgParams;
         
         // create the ground
         var groundGeom = new THREE.PlaneGeometry(p.groundSize, p.groundSize);
         groundGeom.vertexColors = [p.groundColor2,p.groundColor1,p.groundColor1,p.groundColor2];
         // color interpolation algorithm sourced from tw script
         var colors = groundGeom.vertexColors;
         var i, faces = groundGeom.faces, len = faces.length;
         for (i = 0; i < len; ++i) {
            var face = faces[i];
            var facecolors = [];
            facecolors[0] = colors[face.a];
            facecolors[1] = colors[face.b];
            facecolors[2] = colors[face.c];
            face.vertexColors = facecolors;
         }
         
         // create the mesh for the ground
         var groundMesh = new THREE.Mesh(
            groundGeom,
            new THREE.MeshPhongMaterial({
                vertexColors: THREE.VertexColors,
                specular: new THREE.Color("white"),
                shininess: 10,
                flatShading: THREE.FlatShading,
                side: THREE.DoubleSide
                //map: groundTexture //TODO: can temporarily comment out to see without local server
            }));
         groundMesh.rotateX(deg2rad(90));
         
         // add ambient light source
         var ambLight = new THREE.AmbientLight(new THREE.Color("white"), 0.9);
         state.scene.add(ambLight);
         
         state.scene.add(groundMesh);
      }
      
      function createOrb(params) {
         var orbGeom = new THREE.CylinderGeometry(params.orbRadius);
         var orbMesh = new THREE.Mesh(orbGeom, clownMaterials[5]);
         orbMesh.position.x = 0;
         orbMesh.position.y = 0;
         orbMesh.position.z = 0;
         return orbMesh;
      }

      // setupCamera() function creates and returns a camera with the desired parameters
      function setupCamera(cameraParameters) {
         // set up an abbreviation 
         let cp = cameraParameters;
         // create an initial camera with the desired shape
         var camera = new THREE.PerspectiveCamera(cp.fov, cp.aspectRatio, cp.near, cp.far);
         // set the camera location and orientation
         camera.position.set(cp.eyeX, cp.eyeY, cp.eyeZ);
         camera.up.set(cp.upX, cp.upY, cp.upZ);
         camera.lookAt(new THREE.Vector3(cp.atX, cp.atY, cp.atZ));
         return camera;
      }

      function redoCamera() {
         scene.remove(camera);
         camera = setupCamera(cameraParams);
         scene.add(camera)
         render();
      }

      function render() {
         // a render function; assume global variables scene, renderer, and camera
         renderer.render(scene, camera);
      }

      function setupCameraControls() {
         var cameraControls = new THREE.OrbitControls(camera, canvas);
         state.cameraControls = cameraControls;
         cameraControls.addEventListener('change', render);
         cameraControls.update();
      }
         
      function redraw() {
         
         // adjust things to new values

         render();
      }
      
      
/*************************************************

      "main" area
      
*************************************************/
      
      // construct a renderer for the scene
      var renderer = new THREE.WebGLRenderer();
      
      // create the Scene object
      var scene = new THREE.Scene();
      
      // add canvas to the document
      var canvas = renderer.domElement;
      state.renderer = renderer; // save this so that others can use it.
      state.scene = scene;       // save this so that others can use it.
      var parent = document.body;
      parent.appendChild(canvas);
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      renderer.setClearColor(new THREE.Color(0xfefefe), 1);
      
      // add things to the scene
      scene.add(createOrb(params));
      addBackground(bgParams, state);
      
      // camera overhead
      var camera = setupCamera(cameraParams);
      
      render();
      setupCameraControls();

      var gui = new dat.GUI();
      gui.add(turretParams, 'positionX', -100, 100).onChange(redraw);
      gui.add(turretParams, 'positionY', -100, 100).onChange(redraw);
      gui.add(turretParams, 'positionZ', -100, 100).onChange(redraw);
      gui.add(turretParams, 'rotation', -Math.PI*2, Math.PI*2).onChange(redraw);
      gui.add(turretParams, 'bodyHeight', 1, 200).onChange(redraw);
      gui.add(turretParams, 'bodyWidth', 1, 100).onChange(redraw);
      gui.add(turretParams, 'bodyHeight', 1, 200).onChange(redraw);
      gui.add(turretParams, 'bodyWidth', 1, 100).onChange(redraw);
       

    </script>
    <!-- <canvas width="2156" height="600" style="width: 2156px; height: 600px;"></canvas> -->

</body>

</html>