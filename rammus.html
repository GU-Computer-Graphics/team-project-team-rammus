<!DOCTYPE html>
<html lang="en">

<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

   <title>Rammus</title>
   <style>
      canvas {
      display: block;
      margin: 10px auto;
      width: 800px;
      height: 500px;
      }
   </style>

   <script src="./js/three.js"></script>
   <script src="./js/OrbitControls.js"></script>
   <script src="./js/SceneUtils.js"></script>
   <script src="js/dat.gui.js"></script>
   
</head>

<body>
   <h1><center>Rammus Roll</center></h1>
   <script id="rammuscode">
   
/*************************************************

      global variables
      
*************************************************/

      // parameters used in the scene
      var cameraParams = {
         near: 1,
         far: 1000,
         fov: 55, // degrees
         aspectRatio: 800 / 500, // from dimensions of the canvas, see CSS
         atX: 0,
         atY: 0,
         atZ: 0,
         eyeX: 0,
         eyeY: 40,
         eyeZ: 150,
         upX: 0,
         upY: 1,
         upZ: 0
      };
      
      var bgParams = {
         groundColor1: new THREE.Color(0xC2B48C),
         groundColor2: new THREE.Color(0x427646),
         groundSize: 600
      }
      
      var turretParams = {
         positionX: 0,
         positionY: 0,
         positionZ: 0,
         scaleY: 1,
         rotation: 0,
         headSize: 15,
         bodyHeight: 100,
         bodyWidth: 10,
         baseHeightRatio: 0.1,
         baseWidthRatio: 1.2
      }
      
      var params = {
         orbRadius: 1
      };
      
      var state = {};
      // colors and materials for the clown
      var clownMaterials = [
         new THREE.MeshBasicMaterial({ color: 0x8822BB }),  // 0 - purple
         new THREE.MeshBasicMaterial({ color: 0x22CC22 }),  // 1 - green
         new THREE.MeshBasicMaterial({ color: 0xE59B7D }),  // 2 - skin
         new THREE.MeshBasicMaterial({ color: 0x000000 }),  // 3 - black
         new THREE.MeshBasicMaterial({ color: 0xEEEEEE }),  // 4 - off white
         new THREE.MeshBasicMaterial({ color: 0xFFFF00 })   // 5 - yellow
      ];

      // Animations Specific Varaibles
      
      var taurusPosition = {
            x: 0,
            y: 10,
            z: 0,
        }
      const rotationDegree = 5;
      var startingPosition = new THREE.Object3D();
      var taurus = new THREE.Object3D();
      var path = [];
      var tMax = 1000; 
      var t = 0;   
      var startingPosition = new THREE.Object3D();

      var animationId = null;
      var controlPoints = [
         [0, 0,-200],
         [500, 0, 200],
         [-500, 0, 200],
         [0, 0, -200]
      ];
      
      
/*************************************************

      functions
      
*************************************************/

      function deg2rad(degrees) {
         return degrees * 0.0174533;
      }
      
      function createTurret(turretParams) {
         let turret = new THREE.Object3D();
         
         // create the nested parts 
         let body = createBody(turretParams);
         let shield = createShield(turretParams);
         let wand = createWand(turretParams);
         
         // add the parts to the whole
         turret.add(body);
         turret.add(shield);
         turret.add(wand);
         
         // adjust whole
         // TODO: POSITION, ROTATION, SIZE SCALING, ETC
         
         return turret;
      }
      
      function createBody(turretParams) {
         // use alias
         let p = turretParams;
         
         let body = new THREE.Object3D();
         
         // create parts
         let head = new THREE.SphereGeometry(p.headSize, 32, 32);
         let mast = new THREE.CylinderGeometry(p.bodyWidth, p.bodyWidth, p.bodyHeight);
         let base = new THREE.CylinderGeometry(p.bodyWidth, p.bodyWidth, p.bodyHeight/10);
         
         return body;
      }
      
      function createShield(turretParams) {
         let shield = new THREE.Object3D();
         
         
         return shield;
      }
      
      function createWand(turretParams) {
         let wand = new THREE.Object3D();
         
         
         return wand;
      }
      
      // add background stuff such as the ground, skies (TODO), ambient light.
      function addBackground(bgParams, state) {
         let p = bgParams;
         
         // create the ground
         var groundGeom = new THREE.PlaneGeometry(p.groundSize, p.groundSize);
         groundGeom.vertexColors = [p.groundColor2,p.groundColor1,p.groundColor1,p.groundColor2];
         // color interpolation algorithm sourced from tw script
         var colors = groundGeom.vertexColors;
         var i, faces = groundGeom.faces, len = faces.length;
         for (i = 0; i < len; ++i) {
            var face = faces[i];
            var facecolors = [];
            facecolors[0] = colors[face.a];
            facecolors[1] = colors[face.b];
            facecolors[2] = colors[face.c];
            face.vertexColors = facecolors;
         }
         
         // create the mesh for the ground
         var groundMesh = new THREE.Mesh(
            groundGeom,
            new THREE.MeshPhongMaterial({
                vertexColors: THREE.VertexColors,
                specular: new THREE.Color("white"),
                shininess: 10,
                flatShading: THREE.FlatShading,
                side: THREE.DoubleSide
                //map: groundTexture //TODO: can temporarily comment out to see without local server
            }));
         groundMesh.rotateX(deg2rad(90));
         
         // add ambient light source
         var ambLight = new THREE.AmbientLight(new THREE.Color("white"), 0.9);
         state.scene.add(ambLight);
         
         state.scene.add(groundMesh);
      }
      
      function createOrb(params) {
         var orbGeom = new THREE.CylinderGeometry(params.orbRadius);
         var orbMesh = new THREE.Mesh(orbGeom, clownMaterials[5]);
         orbMesh.position.x = 0;
         orbMesh.position.y = 0;
         orbMesh.position.z = 0;
         return orbMesh;
      }

      function moveTaurusFoward() {
            t += 1
            //for debugging and... a big hint
            console.log((t));
            console.log((path[t].x + ", " + path[t].y + ", " + path[t].z));

            //get next point on the path of our bezier curve, we want to move towards it
            let targetDirection = new THREE.Vector3(path[t].x, path[t].y, path[t].z);

            let position = new THREE.Vector3(); //need a vector to store a position
            taurus.getWorldPosition(position); //get car current position -- getWorldPosition requires target return object
            let distance = position.distanceTo(targetDirection); //calculate distance between car and point we want to move towards            
            // console.log("distance: " + distance);
            taurus.lookAt(targetDirection); //"rotate" car to face the point we'll move towards
            taurus.translateZ(distance); //move to the new position (Z because that is the "forward" direction according to how we built the car)

            render(); //update scene
      }

      function animate(timestamp) {
            if(t <tMax) {
                moveTaurusFoward()
                animationId = requestAnimationFrame(animate)
            }
            else {
                stopAnimation()
            }
      }

      function stopAnimation() {
            if (animationId != null) {
                cancelAnimationFrame(animationId);
                console.log("Cancelled animation using " + animationId);
            }
      }

      function showCP(cpList, radius) {
            for (var i = 0; i < cpList.length; i++) {
                scene.add(createPoint(cpList[i], radius));
            }
      };

      function createBezierCurve(cpList, steps) {
            // Using the given list of control points, returns a
            // THREE.Geometry comprising 'steps' vertices, suitable for
            // combining with a material and creating a THREE.Line out of.
            var N = Math.round(steps) + 1 || tMax; // number of vertices

            var geometry = new THREE.Geometry();
            var curve = new THREE.CubicBezierCurve3();

            var cp = cpList[0];
            curve.v0 = new THREE.Vector3(cp[0], cp[1], cp[2]);
            cp = cpList[1];
            curve.v1 = new THREE.Vector3(cp[0], cp[1], cp[2]);
            cp = cpList[2];
            curve.v2 = new THREE.Vector3(cp[0], cp[1], cp[2]);
            cp = cpList[3];
            curve.v3 = new THREE.Vector3(cp[0], cp[1], cp[2]);

            var j, stepSize = 1 / (N - 1);
            for (j = 0; j < N; j++) {
                geometry.vertices.push(curve.getPoint(j * stepSize));
                path.push(curve.getPoint(j * stepSize));
            }
            return geometry;
      };

      // setupCamera() function creates and returns a camera with the desired parameters
      function setupCamera(cameraParameters) {
         // set up an abbreviation 
         let cp = cameraParameters;
         // create an initial camera with the desired shape
         var camera = new THREE.PerspectiveCamera(cp.fov, cp.aspectRatio, cp.near, cp.far);
         // set the camera location and orientation
         camera.position.set(cp.eyeX, cp.eyeY, cp.eyeZ);
         camera.up.set(cp.upX, cp.upY, cp.upZ);
         camera.lookAt(new THREE.Vector3(cp.atX, cp.atY, cp.atZ));
         return camera;
      }

      function redoCamera() {
         scene.remove(camera);
         camera = setupCamera(cameraParams);
         scene.add(camera)
         render();
      }

      function render() {
         // a render function; assume global variables scene, renderer, and camera
         renderer.render(scene, camera);
      }

      function setupCameraControls() {
         var cameraControls = new THREE.OrbitControls(camera, canvas);
         state.cameraControls = cameraControls;
         cameraControls.addEventListener('change', render);
         cameraControls.update();
      }
         
      function redraw() {
         
         // adjust things to new values

         render();
      }
      
      
/*************************************************

      "main" area
      
*************************************************/
      
      // construct a renderer for the scene
      var renderer = new THREE.WebGLRenderer();
      
      // create the Scene object
      var scene = new THREE.Scene();
      
      // add canvas to the document
      var canvas = renderer.domElement;
      state.renderer = renderer; // save this so that others can use it.
      state.scene = scene;       // save this so that others can use it.
      var parent = document.body;
      parent.appendChild(canvas);
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      renderer.setClearColor(new THREE.Color(0xfefefe), 1);
      
      // add things to the scene
      scene.add(createOrb(params));
      addBackground(bgParams, state);


      var taurGeom = new THREE.TorusGeometry( 10, 3, 16, 100 )
      var taurMesh = new THREE.Mesh( taurGeom,new THREE.MeshBasicMaterial( { color: 0xffff00 } ))
      taurMesh.rotation.y = THREE.Math.degToRad(90)
      taurMesh.translateY(10)
      taurus.add(taurMesh)
      scene.add(taurus)
      startingPosition.position.copy(taurus.position);

      var curveGeom = createBezierCurve(controlPoints, tMax);
      var curveMat = new THREE.LineBasicMaterial({
         color: new THREE.Color("blue"),
         linewidth: 3
      });
      var curve = new THREE.Line(curveGeom, curveMat);
      scene.add(curve);
      
      // camera overhead
      var camera = setupCamera(cameraParams);
      
      render();
      setupCameraControls();

      var gui = new dat.GUI();
      gui.add(turretParams, 'positionX', -100, 100).onChange(redraw);
      gui.add(turretParams, 'positionY', -100, 100).onChange(redraw);
      gui.add(turretParams, 'positionZ', -100, 100).onChange(redraw);
      gui.add(turretParams, 'rotation', -Math.PI*2, Math.PI*2).onChange(redraw);
      gui.add(turretParams, 'bodyHeight', 1, 200).onChange(redraw);
      gui.add(turretParams, 'bodyWidth', 1, 100).onChange(redraw);
      gui.add(turretParams, 'bodyHeight', 1, 200).onChange(redraw);
      gui.add(turretParams, 'bodyWidth', 1, 100).onChange(redraw);
       

      document.addEventListener("keypress", (event) => {
            const key = event.key;
            console.log("key pressed was " + key);
            switch (key) {
                case "1":
                    cameraParams.eyeX = -250;
                    cameraParams.eyeY = 100;
                    cameraParams.eyeZ = 200;
                    redoCamera();
                    break;
                case "2":
                    cameraParams.eyeX = 0;
                    cameraParams.eyeY = 30;
                    cameraParams.eyeZ = -300;
                    redoCamera();
                    break;

                case "3":
                    cameraParams.eyeX = 0;
                    cameraParams.eyeY = 60;
                    cameraParams.eyeZ = 300;
                    redoCamera();
                    break;
                case "4":
                    cameraParams.eyeX = 250;
                    cameraParams.eyeY = 260;
                    cameraParams.eyeZ = 0;
                    redoCamera();
                    break;
                case "g":
                    //TODO: it may be helpful if you try to move one step 
                    //      at a time first before animating the whole curve
                    // no changes required here, just a hopefully helpful thought
                    t = 0
                    animate();
                    break;
                case " ":
                    stopAnimation();
                    break;
                case "0":
                    //move the car back to the starting position (variable set at the start)
                    taurus.position.set(startingPosition.position.x, startingPosition.position.y, startingPosition.position.z);
                    //TODO: take note of the lookAt function, this rotates the car to look at the origin.
                    //How is this be helpful? Is this where we want to orient the car? What happens if we don't do this?
                    taurus.lookAt(new THREE.Vector3(0, 0, 0));
                    t = 0; //reset to start over
                    break;
                default:
                    break;
            }
            setupCameraControls();
            render();
        });

    </script>
    <!-- <canvas width="2156" height="600" style="width: 2156px; height: 600px;"></canvas> -->

</body>

</html>